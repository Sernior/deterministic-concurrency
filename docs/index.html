<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>deterministic-concurrency: Documentation deterministic-concurrency</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/Sernior/deterministic-concurrency" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: fixed; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
    <h1>Determinic Concurrency</h1>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">
   </div>
   <br>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part --><!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Documentation deterministic-concurrency </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs-generator_2main-page"></a> <em>F.Abrignani, P. Di Giglio, S. Martorana - <a href="#" onclick="location.href='mai'+'lto:'+'fed'+'er'+'ign'+'ol'+'i@h'+'ot'+'mai'+'l.'+'it'; return false;">feder<span class="obfuscator">.nosp@m.</span>igno<span class="obfuscator">.nosp@m.</span>li@ho<span class="obfuscator">.nosp@m.</span>tmai<span class="obfuscator">.nosp@m.</span>l.it</a> - Version 1.4.5, 14.08.2023</em></p>
<table style="border:none;border-collapse:collapse;">
<tr>
<td style="border:none;border-left:none;border-top:none;border-bottom:none;width: 80px;"><img src="warning.png" alt="" style="width:70px; height:70px; object-fit: cover; object-position: 100% 0;" class="inline"/>  </td><td style="border-right:none;border-top: none;border-bottom: none;">Tool made to test syncronization mechanisms in a deterministic way that does not rely on OS scheduler.<br  />
 Tests should be deterministic and reproducible.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md2"></a>
Overview</h1>
<p>Deterministic Concurrency, as the name suggests, aims to allow the user to create reproducible scheduling sequences so to allow deterministic asserts while testing concurrent algorithms. Controlling the flow of concurrency can be achieved by calling the methods of <code>thread_context</code> and <code>UserControlledScheduler</code>.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Motivation</h1>
<p>This library exists because of a specific need: testing the correctness of my own synchronization primitives. I required a straightforward and readable approach to define precise scheduling sequences for making meaningful assertions. <br  />
 Having used this tool successfully, I found it invaluable for identifying and rectifying bugs and incorrect behaviors in my other projects. As a result of its effectiveness in improving code quality, I've chosen to release this library to the public. I hope that others can also find it useful and straightforward to use.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
DeterministicThread</h1>
<p>Except for those users who wants to contribute to this library, standard users should not be concerned about this class. This definition of thread uses an internal definition of time shared with the <code>UserControlledScheduler</code> to manage context switches.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
thread_context</h1>
<p>Each <code>DeterministicThread</code> has a <code>thread_context</code>, the thread context is then passed to the thread function and contains methods for the <code>DeterministicThread</code> to manage its flow and also to update its state.</p>
<p>Each <code>thread_context</code> contains the state of the <code>DeterministicThread</code> associated with it.</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> thread_status_t{</div>
<div class="line">    RUNNING,</div>
<div class="line">    WAITING,</div>
<div class="line">    NOT_STARTED,</div>
<div class="line">    FINISHED,</div>
<div class="line">    WAITING_EXTERNAL</div>
<div class="line">};</div>
</div><!-- fragment --><p>After the initial invocation of <code>.proceed()</code> or <code>.switchContextTo()</code> from the scheduler, the thread transitions from <code>NOT_STARTED</code> to the <code>RUNNING</code> state.<br  />
 It remains in this state until one of the following conditions is met:</p>
<ol type="1">
<li><b>Completion</b>: The thread completes its task, resulting in a transition to the <code>FINISHED</code> state (also becoming joinable);</li>
<li><b>Context Switch</b>: When the <code>thread_context::switchContext()</code> method is called, the thread's state transitions to <code>WAITING</code> until the scheduler gives it permission to run again;</li>
<li><b>External Lock</b>: If an external lock event occurs, the thread's state changes to <code>WAITING_EXTERNAL</code> until the "external source of waiting" allows it to continue.</li>
</ol>
<h1><a class="anchor" id="autotoc_md6"></a>
UserControlledScheduler</h1>
<p>The <code>UserControlledScheduler</code> manages the creation and the flow of threads.<br  />
 It also creates each deterministic thread ad thread_context object through which the thread can control its flow and decide when to switch context.</p>
<p>Let`s see an example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> custom_syncronization_mechanism m;</div>
<div class="line"><span class="keyword">using namespace </span>DeterministicConcurrency;</div>
<div class="line">thread_function0(<a class="code hl_class" href="classDeterministicConcurrency_1_1thread__context.html">DeterministicConcurrency::thread_context</a>* c){</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Hello!\n&quot;</span>; <span class="comment">// #0</span></div>
<div class="line">    c-&gt;<a class="code hl_function" href="classDeterministicConcurrency_1_1thread__context.html#a5c45bc7e0773560722d8073c48c0fd96">lock</a>(&amp;m); <span class="comment">// #1</span></div>
<div class="line">    c-&gt;<a class="code hl_function" href="classDeterministicConcurrency_1_1thread__context.html#a0a7391dcb6a66e255b088c5c95809627">switchContext</a>(); <span class="comment">// #2</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;name &quot;</span>; <span class="comment">// #3</span></div>
<div class="line">    m.unlock(); <span class="comment">// #4</span></div>
<div class="line">}</div>
<div class="line">thread_function1(<a class="code hl_class" href="classDeterministicConcurrency_1_1thread__context.html">DeterministicConcurrency::thread_context</a>* c){</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;My &quot;</span>; <span class="comment">// #5</span></div>
<div class="line">    c-&gt;<a class="code hl_function" href="classDeterministicConcurrency_1_1thread__context.html#a5c45bc7e0773560722d8073c48c0fd96">lock</a>(&amp;m); <span class="comment">// #6</span></div>
<div class="line">    c-&gt;<a class="code hl_function" href="classDeterministicConcurrency_1_1thread__context.html#a0a7391dcb6a66e255b088c5c95809627">switchContext</a>(); <span class="comment">// #7</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;is &quot;</span>; <span class="comment">// #8</span></div>
<div class="line">    m.unlock(); <span class="comment">// #9</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <span class="keyword">auto</span> thread0 = std::tuple{&amp;thread_function0};</div>
<div class="line">    <span class="keyword">auto</span> thread1 = std::tuple{&amp;thread_function1};</div>
<div class="line">    <span class="keyword">auto</span> sch = <a class="code hl_function" href="UserControlledScheduler_8h.html#a4f4fcaf92dfcd72b8bb9a998cdbd271e">make_UserControlledScheduler</a>(thread0, thread1);</div>
<div class="line">    <span class="comment">// this scheduler is controlling 2 deterministic threads.</span></div>
<div class="line">    <span class="comment">// Deterministic threads are stored as elements in an array within the scheduler,</span></div>
<div class="line">    <span class="comment">// so in this case we have thread0 with index 0 as it is the first argument given to</span></div>
<div class="line">    <span class="comment">// make_UserControlledScheduler and thread1 with index 1.</span></div>
<div class="line">    <span class="comment">// We can use these indexes to control them.</span></div>
<div class="line">    <span class="comment">// As stated these threads are lazy so they are just waiting for sch to do something here.</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    sch.switchContextTo(0); </div>
<div class="line">    <span class="comment">// this will allow thread 0 to proceed and stop the scheduler until thread0 uses switch context</span></div>
<div class="line">    <span class="comment">// on its thread_context or until it finishes.</span></div>
<div class="line">    <span class="comment">// So thread0 will start executing perform #0 taking the lock on m at #1 and then execute #2</span></div>
<div class="line">    <span class="comment">// stopping itself and giving control back to the scheduler</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// at this point assuming m function similarly to a std::mutex, so not allowing also</span></div>
<div class="line">    <span class="comment">// thread0 to go past the lock if we were to perform sch.switchContextTo(1) we would</span></div>
<div class="line">    <span class="comment">// surely deadlock ourselves. So insted we can use proceed() which allows threads to proceed</span></div>
<div class="line">    <span class="comment">// but without stopping the scheduler thread.</span></div>
<div class="line">    sch.proceed(1);</div>
<div class="line">    <span class="comment">// so thread 1 will perform #5 and then get stopped by #6 since the lock is already owned by</span></div>
<div class="line">    <span class="comment">// thread0.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Just to make sure thread1 is actually locked by &#39;m&#39; we can ask the scheduler to wait</span></div>
<div class="line">    <span class="comment">// until thread1 goes into thread_status_t::WAITING_EXTERNAL.</span></div>
<div class="line">    sch.waitUntilAllThreadStatus&lt;thread_status_t::WAITING_EXTERNAL&gt;(1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Right now thread 0 is in state WAITING at #2 and thread 1 is in state WAITING_EXTERNAL at #6.</span></div>
<div class="line">    <span class="comment">// So let`s make thread 0 continue its executing until it finishes.</span></div>
<div class="line">    sch.switchContextTo(0); </div>
<div class="line">    <span class="comment">// Since switchContextTo unlike proceed waits for the thread or threads indexes given as parameters</span></div>
<div class="line">    <span class="comment">// to either context switch back or finish, after this point we know thread 0 is FINISHED</span></div>
<div class="line">    <span class="comment">// and so the mutex has been unlocked.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Since we cannot be sure on when the OS scheduler decides to execute 0 or 1 </span></div>
<div class="line">    <span class="comment">// we can not be sure at this point if 1 was already unlock by &#39;m&#39; or not so</span></div>
<div class="line">    <span class="comment">// so we must wait for it to reach its switchContext at #7</span></div>
<div class="line"> </div>
<div class="line">    sch.waitUntilAllThreadStatus&lt;thread_status_t::WAITING&gt;(1);</div>
<div class="line"> </div>
<div class="line">    sch.switchContextTo(1);</div>
<div class="line"> </div>
<div class="line">    sch.joinAll();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Bob.&quot;</span>;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aUserControlledScheduler_8h_html_a4f4fcaf92dfcd72b8bb9a998cdbd271e"><div class="ttname"><a href="UserControlledScheduler_8h.html#a4f4fcaf92dfcd72b8bb9a998cdbd271e">DeterministicConcurrency::make_UserControlledScheduler</a></div><div class="ttdeci">auto make_UserControlledScheduler(Tuples &amp;&amp;... tuples)</div><div class="ttdoc">describe make_UserControlledScheduler::TODO</div><div class="ttdef"><b>Definition</b> UserControlledScheduler.h:316</div></div>
<div class="ttc" id="aclassDeterministicConcurrency_1_1thread__context_html"><div class="ttname"><a href="classDeterministicConcurrency_1_1thread__context.html">DeterministicConcurrency::thread_context</a></div><div class="ttdoc">Provide the thread with basic functionalities.</div><div class="ttdef"><b>Definition</b> DeterministicThread.h:63</div></div>
<div class="ttc" id="aclassDeterministicConcurrency_1_1thread__context_html_a0a7391dcb6a66e255b088c5c95809627"><div class="ttname"><a href="classDeterministicConcurrency_1_1thread__context.html#a0a7391dcb6a66e255b088c5c95809627">DeterministicConcurrency::thread_context::switchContext</a></div><div class="ttdeci">void switchContext()</div><div class="ttdoc">Notify the scheduler that this thread is ready to give it back the control and wait until the schedul...</div><div class="ttdef"><b>Definition</b> DeterministicThread.h:79</div></div>
<div class="ttc" id="aclassDeterministicConcurrency_1_1thread__context_html_a5c45bc7e0773560722d8073c48c0fd96"><div class="ttname"><a href="classDeterministicConcurrency_1_1thread__context.html#a5c45bc7e0773560722d8073c48c0fd96">DeterministicConcurrency::thread_context::lock</a></div><div class="ttdeci">void lock(BasicLockable *lockable, Args &amp;&amp;... args)</div><div class="ttdoc">Lock lockable and update the current thread_status_v of the current deterministic thread.</div><div class="ttdef"><b>Definition</b> DeterministicThread.h:106</div></div>
</div><!-- fragment --><p>We will end up printing </p><div class="fragment"><div class="line">Hello!</div>
<div class="line">My name is Bob.</div>
</div><!-- fragment --><p> and we successfully controlled the flow of our threads.<br  />
 It is worth noting that on "external sources of waiting" we can<code>t just directly call</code><code>m.lock()</code><code>or</code><code>m.lock_shared()</code><code>so I had to implement</code><code>lock</code><code>and</code><code>lock_shared</code>` as thread_context methods. This is because thread contextes need to know that they could remain stuck on a lock and thus update the thread status to WAITING_EXTERNAL. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
  <hr class="footer"/><address class="footer"><small>
  Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
  </small></address>
  </body>
  </html>