<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>deterministic-concurrency: Documentation deterministic-concurrency</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/Sernior/deterministic-concurrency" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: fixed; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
    <h1>Determinic Concurrency</h1>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">
   </div>
   <br>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part --><!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Documentation deterministic-concurrency </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs-generator_2main-page"></a> <em>F.Abrignani, P. Di Giglio, S. Martorana - <a href="#" onclick="location.href='mai'+'lto:'+'fed'+'er'+'ign'+'ol'+'i@h'+'ot'+'mai'+'l.'+'it'; return false;">feder<span class="obfuscator">.nosp@m.</span>igno<span class="obfuscator">.nosp@m.</span>li@ho<span class="obfuscator">.nosp@m.</span>tmai<span class="obfuscator">.nosp@m.</span>l.it</a> - Version 1.4.5, 14.08.2023</em></p>
<table style="border:none;border-collapse:collapse;">
<tr>
<td style="border:none;border-left:none;border-top:none;border-bottom:none;width: 80px;"><img src="warning.png" alt="" style="width:70px; height:70px; object-fit: cover; object-position: 100% 0;" class="inline"/>  </td><td style="border-right:none;border-top: none;border-bottom: none;">Tool made to test syncronization mechanisms in a deterministic way that does not rely on OS scheduler.<br  />
 Tests should be deterministic and reproducible.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md16"></a>
Overview</h1>
<p>Deterministic Concurrency, as the name suggests, aims to allow the user to create reproducible scheduling sequences so to allow deterministic asserts while testing concurrent algorithms. Controlling the flow of concurrency can be achieved by calling the methods of <span style="color: darkgoldenrod;">thread_context</span> and <span style="color: darkgoldenrod;">UserControlledScheduler</span>.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Motivation</h1>
<p>This library exists because of a specific need: <span style="color: darkgoldenrod;">testing</span> the correctness of my own <span style="color: darkgoldenrod;">synchronization primitives</span>. I required a straightforward and readable approach to define precise scheduling sequences for making meaningful assertions. <br  />
 Having used this tool successfully, I found it invaluable for identifying and rectifying bugs and incorrect behaviors in my other projects. As a result of its effectiveness in improving code quality, I've chosen to release this library to the public. I hope that others can also find it useful and straightforward to use.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
DeterministicThread</h1>
<p>Except for those users who wants to contribute to this library, standard users should not be concerned about this class. This definition of thread uses an internal definition of time shared with the <span style="color: darkgoldenrod;">UserControlledScheduler</span> to manage context switches.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
thread_context</h1>
<p>Each <span style="color: darkgoldenrod;">DeterministicThread</span> has a <span style="color: darkgoldenrod;">thread_context</span>, the thread context is then passed to the thread function and contains methods for the <span style="color: darkgoldenrod;">DeterministicThread</span> to manage its flow and also to update its state.</p>
<p>Each <span style="color: darkgoldenrod;">thread_context</span> contains the state of the <span style="color: darkgoldenrod;">DeterministicThread</span> associated with it.</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> thread_status_t{</div>
<div class="line">    RUNNING,</div>
<div class="line">    WAITING,</div>
<div class="line">    NOT_STARTED,</div>
<div class="line">    FINISHED,</div>
<div class="line">    WAITING_EXTERNAL</div>
<div class="line">};</div>
</div><!-- fragment --><p>After the initial invocation of <code>.proceed()</code> or <code>.switchContextTo()</code> from the scheduler, the thread transitions from <span style="color: darkgoldenrod;">NOT_STARTED</span> to the <span style="color: darkgoldenrod;">RUNNING</span> state.<br  />
 It remains in this state until one of the following conditions is met:</p>
<ol type="1">
<li><b>Completion</b>: The thread completes its task, resulting in a transition to the <span style="color: darkgoldenrod;">FINISHED</span> state (also becoming joinable);</li>
<li><b>Context Switch</b>: When the <code>thread_context::switchContext()</code> method is called, the thread's state transitions to <span style="color: darkgoldenrod;">WAITING</span> until the scheduler gives it permission to run again;</li>
<li><b>External Lock</b>: If an external lock event occurs, the thread's state changes to <span style="color: darkgoldenrod;">WAITING_EXTERNAL</span> until the "external source of waiting" allows it to continue.</li>
</ol>
<h1><a class="anchor" id="autotoc_md20"></a>
UserControlledScheduler</h1>
<p>The <span style="color: darkgoldenrod;">UserControlledScheduler</span> manages the creation and the flow of threads.<br  />
 It also creates each deterministic thread ad thread_context object through which the thread can control its flow and decide when to switch context.</p>
<p>Let`s see an example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> custom_syncronization_mechanism m;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>DeterministicConcurrency;</div>
<div class="line"> </div>
<div class="line">thread_function0 (<a class="code hl_class" href="classDeterministicConcurrency_1_1thread__context.html">DeterministicConcurrency::thread_context</a>* c) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Hello!\n&quot;</span>;    <span class="comment">// #0</span></div>
<div class="line">    c-&gt;<a class="code hl_function" href="classDeterministicConcurrency_1_1thread__context.html#a5c45bc7e0773560722d8073c48c0fd96">lock</a>(&amp;m);                <span class="comment">// #1</span></div>
<div class="line">    c-&gt;<a class="code hl_function" href="classDeterministicConcurrency_1_1thread__context.html#a0a7391dcb6a66e255b088c5c95809627">switchContext</a>();         <span class="comment">// #2</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;name &quot;</span>;       <span class="comment">// #3</span></div>
<div class="line">    m.unlock();                 <span class="comment">// #4</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">thread_function1 (<a class="code hl_class" href="classDeterministicConcurrency_1_1thread__context.html">DeterministicConcurrency::thread_context</a>* c) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;My &quot;</span>;         <span class="comment">// #5</span></div>
<div class="line">    c-&gt;<a class="code hl_function" href="classDeterministicConcurrency_1_1thread__context.html#a5c45bc7e0773560722d8073c48c0fd96">lock</a>(&amp;m);                <span class="comment">// #6</span></div>
<div class="line">    c-&gt;<a class="code hl_function" href="classDeterministicConcurrency_1_1thread__context.html#a0a7391dcb6a66e255b088c5c95809627">switchContext</a>();         <span class="comment">// #7</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;is &quot;</span>;         <span class="comment">// #8</span></div>
<div class="line">    m.unlock();                 <span class="comment">// #9</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <span class="keyword">auto</span> thread0 = std::tuple{&amp;thread_function0};</div>
<div class="line">    <span class="keyword">auto</span> thread1 = std::tuple{&amp;thread_function1};</div>
<div class="line">    <span class="keyword">auto</span> sch = <a class="code hl_function" href="UserControlledScheduler_8h.html#a4f4fcaf92dfcd72b8bb9a998cdbd271e">make_UserControlledScheduler</a>(thread0, thread1);</div>
<div class="line">    sch.switchContextTo(0);     <span class="comment">// #1.1</span></div>
<div class="line">    sch.proceed(1);</div>
<div class="line">    sch.waitUntilAllThreadStatus&lt;thread_status_t::WAITING_EXTERNAL&gt;(1);</div>
<div class="line">    sch.switchContextTo(0);     <span class="comment">// #1.2</span></div>
<div class="line">    sch.waitUntilAllThreadStatus&lt;thread_status_t::WAITING&gt;(1);</div>
<div class="line">    sch.switchContextTo(1);</div>
<div class="line">    sch.joinAll();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Bob.&quot;</span>;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aUserControlledScheduler_8h_html_a4f4fcaf92dfcd72b8bb9a998cdbd271e"><div class="ttname"><a href="UserControlledScheduler_8h.html#a4f4fcaf92dfcd72b8bb9a998cdbd271e">DeterministicConcurrency::make_UserControlledScheduler</a></div><div class="ttdeci">auto make_UserControlledScheduler(Tuples &amp;&amp;... tuples)</div><div class="ttdoc">Helper function to create an UserControlledScheduler.</div><div class="ttdef"><b>Definition</b> UserControlledScheduler.h:255</div></div>
<div class="ttc" id="aclassDeterministicConcurrency_1_1thread__context_html"><div class="ttname"><a href="classDeterministicConcurrency_1_1thread__context.html">DeterministicConcurrency::thread_context</a></div><div class="ttdoc">Provide the thread with basic functionalities.</div><div class="ttdef"><b>Definition</b> DeterministicThread.h:65</div></div>
<div class="ttc" id="aclassDeterministicConcurrency_1_1thread__context_html_a0a7391dcb6a66e255b088c5c95809627"><div class="ttname"><a href="classDeterministicConcurrency_1_1thread__context.html#a0a7391dcb6a66e255b088c5c95809627">DeterministicConcurrency::thread_context::switchContext</a></div><div class="ttdeci">void switchContext()</div><div class="ttdoc">Notify the scheduler that this thread is ready to give it back the control and wait until the schedul...</div><div class="ttdef"><b>Definition</b> DeterministicThread.h:83</div></div>
<div class="ttc" id="aclassDeterministicConcurrency_1_1thread__context_html_a5c45bc7e0773560722d8073c48c0fd96"><div class="ttname"><a href="classDeterministicConcurrency_1_1thread__context.html#a5c45bc7e0773560722d8073c48c0fd96">DeterministicConcurrency::thread_context::lock</a></div><div class="ttdeci">void lock(BasicLockable *lockable, Args &amp;&amp;... args)</div><div class="ttdoc">Lock lockable and update the current thread_status_v of the current deterministic thread.</div><div class="ttdef"><b>Definition</b> DeterministicThread.h:112</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21"></a>
Explanation:</h2>
<div class="fragment"><div class="line"><span class="keyword">auto</span> thread0 = std::tuple{&amp;thread_function0};</div>
<div class="line"><span class="keyword">auto</span> thread1 = std::tuple{&amp;thread_function1};</div>
<div class="line"><span class="keyword">auto</span> sch = <a class="code hl_function" href="UserControlledScheduler_8h.html#a4f4fcaf92dfcd72b8bb9a998cdbd271e">make_UserControlledScheduler</a>(thread0, thread1);</div>
</div><!-- fragment --><p> This scheduler is controlling <span style="color: darkgoldenrod;">2 determistic threads</span>. Deterministic threads are stored as elements in an array within the scheduler, so in this case we have <code>thread0</code> with index <span style="color: darkgoldenrod;">0</span> as it is the first argument given to <code>make_UserControlledScheduler</code> and <code>thread1</code> with index <span style="color: darkgoldenrod;">1</span>. We can use these indexes to control them. As stated these threads are lazy so they are just waiting for sch to do something here.</p>
<div class="fragment"><div class="line">sch.switchContextTo(0);     <span class="comment">// #1.1</span></div>
</div><!-- fragment --><p>This will allow <code>thread0</code> to proceed and stop the scheduler until thread0 uses switch context on its <code>thread_context</code> or until it finishes. So <code>thread0</code> will start executing perform <span style="color: darkgoldenrod;">#0</span> taking the lock on m at <span style="color: darkgoldenrod;">#1</span> and then execute <span style="color: darkgoldenrod;">#2</span> stopping itself and giving control back to the scheduler.<br  />
</p>
<p>At this point assuming <code>m</code> function similarly to a <code>std::mutex</code>, it will not allow <code>thread1</code> to go past the lock; if we were to perform <code>sch.switchContextTo(1)</code> we would surely deadlock ourselves. So, instead, we can use <code>proceed()</code> which allows threads to proceed but without stopping the scheduler thread.</p>
<div class="fragment"><div class="line">sch.proceed(1);</div>
</div><!-- fragment --><p>So <code>thread1</code> will perform <span style="color: darkgoldenrod;">#5</span> and then get stopped by <span style="color: darkgoldenrod;">#6</span> since the lock is already owned by <code>thread0</code>.<br  />
 Just to make sure <code>thread1</code> is actually locked by <code>m</code> we can ask the scheduler to wait until <code>thread1</code> goes into <code>thread_status_t::WAITING_EXTERNAL</code>.</p>
<div class="fragment"><div class="line">sch.waitUntilAllThreadStatus&lt;thread_status_t::WAITING_EXTERNAL&gt;(1);</div>
</div><!-- fragment --><p>Right now <code>thread0</code> is in state WAITING at <span style="color: darkgoldenrod;">#2</span> and <code>thread1</code> is in state <span style="color: darkgoldenrod;">WAITING_EXTERNAL</span> at <span style="color: darkgoldenrod;">#6</span>. <br  />
 So let's make <code>thread0</code> continue its executing until it finishes.</p>
<div class="fragment"><div class="line">sch.switchContextTo(0);     <span class="comment">// #1.2</span></div>
</div><!-- fragment --><p>Since <code>switchContextTo()</code> unlike proceed waits for the thread or threads indexes given as parameters to either context switch back or finish, after this point we know thread0 is <span style="color: darkgoldenrod;">FINISHED</span> and so the mutex has been unlocked.<br  />
 Since we cannot be sure on when the OS scheduler decides to execute <code>thread0</code> or <code>thread1</code> we can not be sure at this point if <code>thread1</code> was already unlocked by <code>m</code> or not so so we must wait for it to reach its switchContext at <span style="color: darkgoldenrod;">#7</span>.</p>
<div class="fragment"><div class="line">sch.waitUntilAllThreadStatus&lt;thread_status_t::WAITING&gt;(1);</div>
<div class="line">sch.switchContextTo(1);</div>
<div class="line">sch.joinAll();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Bob.&quot;</span>;</div>
</div><!-- fragment --><p>We will end up printing:</p>
<div class="fragment"><div class="line">Hello!</div>
<div class="line">My name is Bob.</div>
</div><!-- fragment --><p>and we successfully controlled the flow of our threads.</p>
<p>It is worth noting that on "external sources of waiting" we can't just directly call <code>m.lock()</code> or <code>m.lock_shared()</code> so I had to implement <span style="color: darkgoldenrod;">lock</span> and <span style="color: darkgoldenrod;">lock_shared</span> as <code>thread_context</code> methods. This is because thread contextes need to know that they could remain stuck on a lock and thus update the thread status to <span style="color: darkgoldenrod;">WAITING_EXTERNAL</span>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
  <hr class="footer"/><address class="footer"><small>
  Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
  </small></address>
  </body>
  </html>